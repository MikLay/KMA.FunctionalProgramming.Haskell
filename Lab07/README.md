Робота №07
----------

*Потоки і числа Фібоначчі*

Тип Stream (Потік) представляє списки, котрі *повинні* завжди бути
нескінченними. Звичайні списки можуть бути як нескінченними так і
скінченними.

***data*** Stream a = Cons a (Stream a)

Є лише один конструктор Cons. Немає такого об»єкту як *порожній потік*.

Потік -- це просто елемент, за яким слідує потік.

Числа Фібоначчі F~n~ - це послідовність цілих, що починається з 1 і 1,
кожне наступне ціле число в послідовності є сума двох попередніх. Тобто

> *F~0~ = 1*
>
> *F~1~ = 1*
>
> *F~n~ = F~n-1~ + F~n-2~ (n ≥2)*

Наприклад, перші п»ятнадцять чисел Фібоначчі є

> *1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,...*

Легко написати рекурсивну функцію, що обраховує n-те число Фібоначчі
F~n.~ Але час її виконання *експонента* в степені *n*.

Можна визначити нескінченний список чисел Фібоначчі. Для обчислення
перших n елементів цього списку потрібно (близько) n операцій додавання.

Можна обчислити n-те число Фібоначчі лише за *O(log n)* арифметичних
операцій (довільної точності). Для цього використовують 2x2 матрицю F,
що визначена

> F = $\left| \begin{matrix}
> 1 & 1 \\
> 1 & 0 \\
> \end{matrix} \right|$

Якщо послідовно підносити F до степеню, то отримаємо

F^2^ = $\begin{bmatrix}
1 & 1 \\
1 & 0 \\
\end{bmatrix}$ $\begin{bmatrix}
1 & 1 \\
1 & 0 \\
\end{bmatrix}$ = $\begin{bmatrix}
1*1 + 1*1 & 1*1 + 1*0 \\
1*1 + 0*1 & 1*1 + 0*0 \\
\end{bmatrix}$ = $\begin{bmatrix}
2 & 1 \\
1 & 0 \\
\end{bmatrix}$

F^3^ = $\begin{bmatrix}
2 & 1 \\
1 & 0 \\
\end{bmatrix}$ $\begin{bmatrix}
1 & 1 \\
1 & 0 \\
\end{bmatrix}$ = $\begin{bmatrix}
3 & 2 \\
2 & 1 \\
\end{bmatrix}$

F^4^ = $\begin{bmatrix}
3 & 2 \\
2 & 1 \\
\end{bmatrix}$ $\begin{bmatrix}
1 & 1 \\
1 & 0 \\
\end{bmatrix}$ = $\begin{bmatrix}
5 & 3 \\
3 & 2 \\
\end{bmatrix}$

F^5^ = $\begin{bmatrix}
5 & 3 \\
3 & 2 \\
\end{bmatrix}$ $\begin{bmatrix}
1 & 1 \\
1 & 0 \\
\end{bmatrix}$ = $\begin{bmatrix}
8 & 5 \\
5 & 3 \\
\end{bmatrix}$

Можна визначити, що F^n^ = $\begin{bmatrix}
F(n + 1) & F(n) \\
F(n) & F(n - 1) \\
\end{bmatrix}\ \ \ \ д$ля всіх n≥1. F(n-1), F(n), F(n+1) відповідно n-1,
n і , n+1 числа Фібоначчі. Якщо використати *алгоритм бінарного
піднесення до степені,* то для обрахування матриці F^n^ потрібно лише
*O(log n)* множень .

Наступний тип Matrix представляє матриці 2x2 чисел

> ***data*** Matrix a = M(a,a)(a,a) deriving (Show, Eq, Ord)

Якщо зробити цей тип екземпляром класу типів Num, то для обчислення F^n^
можна використати Haskell оператор піднесення до степені (\^), який
*вже* використовує алгоритм бінарного піднесення до степені.

На основі допоміжного файлу, котрий включає визначення типів, допоміжних
функцій і даних для тестування, створити файл, в якому надати визначення
наступних функцій, потоків та екземплярів класів типів.

1.  Функція *streamToList st,* котра перетворює (конвертує) Stream в
    нескінечний список.

2.  Встановити тип *Stream a* екземпляром класу типів *Functor*,
    реалізувавши функцію *fmap.*

3.  Прості функції - засоби для роботи з потоками

    -   *sRepeat v --* генерує потік, що містить нескінченну кількість
        копій *v.*

    -   *sIterate f v*, котра генерує потік з «зернини» значення *v*, що
        є першим елементом потоку, і «розгортаючого правила» функції
        *f*, що специфікує як побудувати новий елемент потоку з
        попереднього.

    -   *sInterleave s1 s2,* котра зливає елементи двох потоків.

    -   *sTake n s,* котра будує за потоком *s* список, що містить перші
        *n* елементів потоку.

> Наприклад:

-   sIterate ('x' :) "o" = \["o", "xo", "xxo", "xxxo", ...

-   sInterleave (sRepeat 0) (sRepeat 1) = \[0, 1, 0, 1, 0,1, ...

-   sTake 3 (sRepeat 0) = \[0, 0, 0\]

4.  Потік *nats,* котрий містить нескінченний список натуральних чисел
    0, 1, 2,\...

5.  Потік *ruler,* n-елемент якого це найбільша степінь 2, котра націло
    ділить n. Припускається, що перший елемент потоку відповідає n=1.
    Початок потоку має вигляд *0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
    0, 4, ...*

6.  Функція *rand r0,* котра генерує потік «псевдо-випадкових» чисел,
    використовуючи *лінійний конгруентний генератор* з початковим
    значення *r0.* Формула для генератора має вид:

    -   *r~n~ = (1103515245 \* r~n-1~ + 12345) **mod** 2147483648 (n
        ≥1)*

7.  Рекурсивна функція *fib n*, що обраховує n-те число Фібоначчі
    *F~n\ ~*. Використайте *fib* щоб визначити *нескінченний список*
    всіх чисел Фібоначчі *fibs1*. Наприклад:

    -   fib 0 =1

    -   take 5 fibs1 = \[1,1,2,3,5\]

8.  Нескінченний список *fibs2,* котрий має ті самі елементи, що і
    fibs1, але для обчислення його перших n елементів потрібно n
    операцій додавання. Зауваження: *fibs2 = 1 : 1 :* ... і можна
    скористатися функціями *zipWith* і *tail.*

9.  Встановіть тип *Matrix a* екземпляром класу типів *Num*. Реалізуйте
    методи (\*), fromInteger, negate і (+). Функції abs і signum
    реалізовувати не потрібно.

10. Функція *fastFib n*, котра обраховує n-те число Фібоначчі виконуючи
    піднесення в *n*-ту степінь F і вибираючи *F(n).* Врахуйте, що F^n^
    визначено, лише $д$ля n≥1.

    -   fastFib 2 = 2

*streamToList* :: Stream a -\> \[a\]

*sRepeat* :: a -\> Stream a

*sIterate* :: (a -\> a) -\> a -\> Stream a

*sInterleave* :: Stream a -\> Stream a -\> Stream a

*sTake* :: Int -\> Stream a -\> \[a\]

*nats, ruler* :: Stream Integer

*rand* :: Integer -\> Stream Integer

*fib* :: Integer -\> Integer

*fibs1, fib2* :: \[Integer\]

*fastFib* :: Integer -\> Integer

Зауваження:

Назва файлу Family07.hs (Family -- прізвище студента). Файл включає
модуль Family07 і створюється на основі файла-заготовки HWI07.hs
