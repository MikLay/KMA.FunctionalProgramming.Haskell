Робота №03
----------

*Бики і корови*

Бики і корови -- це гра для двох гравців по розгадуванню числа. Один
гравець шифрувальник і другий -- дешифрувальник. На початку гри,
шифрувальник загадує код. Код це число - рядок з декількох десяткових
цифр. Дешифрувальник, знаючи довжину коду, повинен розгадати код - рядок
за мінімальну кількість кроків.

В подальшому в прикладах вважається, що код -- це рядок з *чотирьох*
десяткових чисел.

З кожним кроком, дешифрувальник робить спробу розгадати код, пропонуючи
свій рядок з чотирьох десяткових цифр. Потім шифрувальник повідомляє
скільки цифр у спробі опинилося на тих же місцях, що і у коді,
(кількість «биків») і скільки ще цифр спроби присутні у коді але стоять
на інших позиціях (кількість «корів»). Наприклад, якщо загадано код
«1589» і спроба - рядок «1158», то відповідь: 1 «бик» і 2 «корови».
Перша одиниця на своєму місці - 1 «бик», цифри 5 і 8 не на своїх місцях
-- 2 «корови». Друга одиниця була б «коровою», лише коли немає першої,
наприклад для спроби «7158»

***type*** Code = String

***data*** Move = Move Code Int Int deriving (Show, Eq)

Код - рядок, який загадав шифрувальник, і спроба -- рядок, який
запропонував дешифрувальником, задаються як списки цифр Code. Кожна
цифра -- це символ від '0' до '9'. Для представлення одного кроку
використовується тип Move. Кожне дане цього типу має вид *Move att f p*
- де *att --* список з чотирьох цифр (спроба дешифрувальника), а *f* і
*p* -- відповідь шифрувальника (кількість «биків» *f* та «корів» *p)*.
Наприклад, якщо загадано код рядок "1589" і спроба - рядок "1158", то
крок гри буде (Move "1158" 1 2)

Говорять, що рядок (Code) *cd* *узгоджений* з кроком *Move att f p,*
якщо спроба *att* має таку ж саму кількість «биків» *f* і «корів» *p* з
рядком *cd*, як із рядком -- кодом шифрувальника, що породив цей хід.

Простий алгоритм гри для розгадування коду з n цифр:

-   Генеруються всі можливі коди -- впорядкований за зростанням список
    рядків з n десяткових цифр.

-   Повторюються наступні дії, доки в списку не залишиться один код:

    -   Чергова спроба *att* -- це перший код в списку.

    -   Формується крок *Move att f p* .

    -   Список фільтрується, залишаючи лише ті коди, що узгоджені з цим
        кроком.

В допоміжному файлі, котрий включає визначення типів, надати визначення
наступних функцій.

1.  Функція *exactMatches cd att*, котра за кодом (рядок *cd*) та
    спробою (рядок *att*) визначає кількість «биків» - цифр в спробі, що
    опинилися на тих же місцях, що і у коді. Наприклад:

    -   exactMatches "1589" "5891" = 0

    -   exactMatches "1589" "1159" = 2

2.  Функція *countDigits cd,* котра повертає список, що містить скільки
    разів кожна десяткова цифра з»явився в рядку-коді *cd.* Перший
    елемент результату -- кількість цифр '0', другий -- '1' , .. ,
    десятий елемент -- '9'. Наприклад:

    -   countDigits"1589" = \[0,1,0,0,0,1,0,0,1,1\]

    -   countDigits"1117" = \[0,3,0,0,0,1,0,1,0,0\]

3.  Функція *matches cd att,* котра повертає кількість співпадаючих цифр
    у рядках коду *cd* і спроби *att* (загальна сума «биків» і «корів»).
    Потрібно підрахувати кількість входжень кожної цифри в обох рядках
    (*countDigits*) і взяти мінімальне значення для кожної з цифр.
    Наприклад:

    -   matches "1589" "1158" = 3

4.  Функція *getMove cd att*, котра за кодом *cd* та спробою *att*
    формує один крок (Move). Наприклад:

    -   getMove "1589" "1158" = Move "1158" 1 2

5.  Функція *isConsistent mv cd*, що перевіряє узгодженість коду *cd* з
    кроком *mv*. Наприклад:

    -   isConsistent (Move "2257" 1 1) "2519" = True

    -   isConsistent (Move "2257" 1 1) "2529" = False

6.  Функція *filterCodes mv cdx*, котра фільтрує список кодів (рядки
    цифр) *cdx*, залишаючи лише ті елементи, що узгоджені з кроком *mv*
    .

    -   filterCodes (Move \"2257\" 1 1) \[\"2519\", \"2521\",
        \"2529\",\"2562\", \"2583\"\] = \["2519","2583"\]

7.  Функція *allCodes n*, котра генерує впорядкований список всіх кодів,
    тобто всі комбінації з 10 цифр довжини *n.* Можна використати
    допоміжну функцію *extand* *cdx d*, котра бере *cdx* - всі
    впорядковані коди довжини (n-1) і використовує їх, створюючи всі
    впорядковані коди довжини n, що починаються з цифри *d*.

    -   take 12 (allCodes 2) =
        \["00","01","02","03","04","05","06","07","08","09","10","11"\]

8.  Функція *solve cd,* що бере рядок-код *cd* і створює список кроків,
    розв\'язуючи гру за простим алгоритмом. Оскільки всі можливі коди --
    впорядкований список рядків з *n* десяткових цифр (*n=length cd*),
    то перший крок завжди починається зі спроби-рядка, що містить *n*
    цифр *'0' («0...0»).*

    -   solve "0301" = \[Move \"0000\" 2 0, Move \"0011\" 2 1, Move
        \"0201\" 3 0, Move \"0301\" 4 0\]

exactMatches :: Code -\> Code -\> Int

countColors :: Code -\> \[Int\]

matches :: Code -\> Code -\> Int

getMove :: Code -\>Code -\> Move

isConsistent :: Move -\>Code -\> Bool

filterCodes :: Move -\> \[Code\] -\> \[Code\]

allCodes :: Int -\> \[Code\]

solve :: Code -\> \[Move\]

Зауваження:

Назва файлу Family03.hs (Family -- прізвище студента). Файл включає
модуль Family03 і створюється на основі файла-заготовки HW03.hs
